\chapter{Implementation details}
\label{chapter4}
\thispagestyle{empty}

\section{System architecture}
Our tool is entirely based on PIN, a binary instrumentation framework developed by Intel. It lets us to have the instruction-level granularity useful to track memory writes on a finer grain. In this way we are able, for example, to see where a single assembly write instruction is going to write and consequently create the write sets.\\
We have integrated Scylla, an external open source program, to dump the code and reconstruct the IAT. Moreover we have extended it in order to deal with \textit{IAT Redirection} and \textit{Stolen API} techniques.\\
Finally we use the IDA Pro disassembler and an IDAPython script in the \textit{Init function calls} heuristic. The script calls IDA which reads the imports of the dump and compare them to a list of functions commonly used by the malware and not by the packer (registry manipulation, internet communication).

\section{System details}
In this section we are going to explain in detail the implementation of the most important parts of our tool.

\subsection{WriteSet management}
We introduced the concept of \textit{WriteInterval} in order to group together contiguous writes, in order to check if an instruction executes from a previously written memory area. All the \textit{WriteIntervals} are grouped together in a \textit{WriteSet}, a simple C++ vector.\\
A \textit{WriteInterval} is a C++ structure with the following fields:
\begin{itemize}
\item addr\_begin
\item addr\_end
\item entropy\_flag
\item long\_jmp\_flag
\item jmp\_outer\_section\_flag
\item pushad\_popad\_flag
\item broken\_falg
\item detectedFunctions
\item cur\_number\_jmp
\item heap\_flag
\end{itemize}
The following steps explain how \textit{WriteInterval} are created and updated:
\begin{enumerate}
\item for each instruction we check if it is a write
\item if so, we insert a \textit{callback} function before it. A \textit{callback} is a feature of PIN: it allows to instrument the code by inserting some code that will be executed before or after the original instruction. In our case, we intercept the write instruction and before the execution we retrieve its EIP, the address where it will write and the size of the memory that will be written
\item Now we proceed to the construction or the update of the \textit{WriteInterval}. We have five cases:
	\begin{enumerate}
	\item the memory written by the instruction neither is contained nor overlaps with another \textit{WriteInterval}. In this case we create a new one and add it to the \textit{WriteSet} vector
	\item the start address of the write is before the start of a \textit{WriteInterval}, but the end address is inside the same \textit{WriteInterval} In this case we update the \textit{WriteInterval} setting as start address the start of the write, but leaving unaltered the end address
	\item the same as case (b), but this time regarding the end address. Consequently, we only update the end of the \textit{WriteInterval} 
	\item the memory written by the instruction completely contains a \textit{WriteInterval}. In this case we update both the start and the end of the \textit{WriteInterval}
	\item the memory written by the instruction is completely contained by an existing \textit{WriteInterval}. In this case we do nothing
	\end{enumerate}
\end{enumerate}