Nowadays, malwares are a widespread and a well-know problem and almost everyone who owns an electronic device connected to a network has to deal with it. Everyday thousands of new malwares are released: viruses, trojans, worms, etc. Moreover, recently malware authors have adopted two countermeasures against antiviruses: packing the original executable, using common packers like UPX or custom packers, and evasion techniques. The former makes difficult to statically analyse the malware, the latter to dynamically analyse it. When run, instances of these kinds of malwares extract in some way their code, that was obfuscated at compile time, and execute it. During execution they often use some routines to fingerprint the environment, in order to check if they are run in a sandbox or if a debugger is attached to them. In this way malwares can exhibit a different behaviour depending on if they are analysed.\\
Many approaches have been proposed to solve the problem of packing: OmniUnpack is one of the most effective in identifying malign executables tracking system calls at a page level and triggering an antivirus when necessary; Eureka, another powerful approach, uses heuristics and dynamic analysis to find the original entry point of the program (OEP) and to resolve obfuscated API. However, both oh them do not reconstruct the original working binary and are vulnerable to evasion techniques of the malwares.\\
Our approach combines static analysis with dynamic analysis: using an instruction level granularity we first statically analyse our instruction, triggering some heuristics in order to check if we have reached the entry point, then we dynamically analyse it to eventually patch some evasion attempts. The result of our approach is in the best case a working dump with the original code of the malware, but in the other cases we still produce some dumps, even not working, that can be useful in statically analysis. In fact, even if the dumps do not work, probably because not all the imports have been correctly resolved, the rest of the code can be part of the original binary and it is possible that the entry point is correct.\\
Our tool is divided in two parts: the unpacking part and the anti-evasion part. From now on we are going to focus only on the unpacking part, the anti-evasion one is discussed in another paper. The unpacking part makes use of PIN, a tool of dynamic instrumentation developed by Intel: it lets us track every instruction and especially every write, in order to detect if an instruction executes from a block of memory previously written. If this is the case, we dump the code and try to reconstruct the Import Address Table using Scylla, an external open source plug-in. Then we trigger our heuristics to determine the validity of the dump; in this part we use also the IDA Pro disassembler to get the list of import of the reconstructed dump.\\
INSERIRE DUE RIGHE SUI TEST EFFETTUATI\\