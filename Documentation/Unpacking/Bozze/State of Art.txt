Dealing with packed malwares is one of the major challenges for software reverse engineers and the security community: there have been several recent attempts at building automated and generic tools for unpacking malwares. However, the majority of them is not useful in extracting the original working executable.\\
PolyUnpack was one of the first projects to automatically extract hidden code from an executable combining static and dynamic analysis. It performs static analysis on the executable in order to create a model (sequence of instructions) of the malware before execution. Then, it is run in a Virtual Machine and every executed instruction is compared to the static model in order to identify newly-generated code. However, this approach is vulnerable to evasion techniques and to fingerprints of the virtual environment in which the malware is run. Both these problem can be mitigated but not eliminated. Moreover, incorrectly disassembly of the original binary will determine false positive unpacked instructions. Lastly, the extracted code is not directly runnable: calls, jumps and imports must be resolved before obtaining a working version of the unpacked malware.\\
Another approach which combines static and dynamic analysis together is that of Eureka. In order to unpack the malware, heuristics are used: the first one assumes that just before the exit all the program code has been unpacked, but this is true only up to 4-level packers; the second one is a statistical approach based on bigram analysis. Moreover, some techniques of API resolution are included in the project. Eureka must deal with evasion based on fingerprinting the Virtual Machine in which the malware is run and with evasion based on its heuristics. More sophisticated API obfuscation can also be a problem.\\
Like PolyUnpack, Renovo uses a fine-grained execution monitoring approach to track unpacking progress and considers the execution of newly written code as an indicator of unpack completion. Using shadow pages it monitors if the instruction pointer jumps to a memory region written after the program start-up. If this is the case, then a hidden layer is discovered and the address pointing to it is considered the OEP. Renovo has to address the problem of the emulated environment detection and the evasion techniques commonly used by malware. In addition, it is difficult to reconstruct the original working binary.\\
OmniUnpack, on the opposite, uses a coarse-level approach in order to track all pages written and executed. Everytime a specific system call is called in a memory area previously written, then the algorithm triggers malware detection on all pages modified since the last dangerous system call. This is good for performances, but can lead to many false positives. Moreover, since the purpose of the approach is to work together with an antivirus on a bare-metal machine, it is not suitable for recovering the original code.\\
JustIn is another analyser that works together with an antivirus. It uses the same methods as OmniUnpack: changing permissions to the pages in the executable's virtual memory and catching the exceptions when the program tries to access its memory with a different privilege. In this way, it is able to detect when a program is trying to execute some instructions in a block of memory previously written and trigger the Antivirus scan, as well as some heuristics to detect the end of unpacking stage. Just like previous approaches, JustIn's heuristics can fail in detecting the correct moment of unpacking. Malwares can also fingerprint the techniques used to instrument the code, like API call interception instructions.\\
The approach of BRC is completely different: instead of focusing on finding the OEP and retrieving the original code, the project aims to correctly identify self-contained code fragments, like decryption and encryption routines, in binary and extract their interface. In this way, the decryption routine can be used to automatically unpack the malware and get its original code. However, these code fragments must satisfy some requirements that limit the applicability of this approach: the function interface must be as simple as possible and have a fixed parameter list, without recursive structures, calls to system calls and code that explicitly uses its own location. Moreover, there is the need of some heuristics to find the OEP of the decryption function in the malware code.\\
Ether relies only on dynamic execution of the malware, with the purpose of providing a transparent malware analyser, that reside completely outside of the target OS environment, using an application of hardware virtualization extension. Thus, there are no in-guest software components vulnerable to detection, and there are no shortcomings that arise from incomplete or inaccurate system emulation. It can monitoring instruction execution, memory writes and system calls execution, as well as limiting the scope of a chosen process. However, in the current implementation, Ether indirectly modifies the memory hierarchy (the cache and the TLB), so it is vulnerable to memory hierarchy attacks. It can also be detected by timing attacks using external inputs, since Ether can only mitigate in-guest timing detection.
